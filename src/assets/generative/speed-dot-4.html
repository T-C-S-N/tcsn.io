<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Speed Dot</title>

   <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
</head>

<body>
   <style>
      html,
      body {
         margin: 0;
         padding: 0;
         display: flex;
         justify-content: center;
         align-items: center;
         width: 100vw;
         height: 100vh;
      }
   </style>

   <script>
      const canvasWidth=490;
      const canvasHeight=490;
      const margin=[
         [5, 5],
         [5, 5],
      ];
      const maxOs=25;
      const os=[];
      const osRadius=10;

      function circlesIntersect(x1, y1, r1, x2, y2, r2) {
         return Math.hypot(x1-x2, y1-y2)<r1+1+r2+1;
      }

      function bounce(x1, y1, vx1, vy1, x2, y2, vx2, vy2) {
         // Calculate the distance between the centers of the circles
         const dx=(x1-x2);
         const dy=(y1-y2);
         const distance=Math.sqrt(dx*dx+dy*dy);

         // Calculate the normal vector between the two circles
         const nx=dx/distance;
         const ny=dy/distance;

         // Calculate the tangent vector
         const tx=-ny;
         const ty=nx;

         // Project the velocities of the circles onto the normal and tangent vectors
         const dv1n=vx1*nx+vy1*ny;
         const dv1t=vx1*tx+vy1*ty;
         const dv2n=vx2*nx+vy2*ny;
         const dv2t=vx2*tx+vy2*ty;

         // Calculate the new normal velocities using the formula for elastic collision
         const v1n=dv2n;
         const v2n=dv1n;

         // The tangential velocities remain unchanged
         const v1t=dv1t;
         const v2t=dv2t;

         // Convert the normal and tangential velocities back into regular x and y velocities
         vx1=v1n*nx+v1t*tx;
         vy1=v1n*ny+v1t*ty;
         vx2=v2n*nx+v2t*tx;
         vy2=v2n*ny+v2t*ty;

         return [vx1, vy1, vx2, vy2];
      }

      function getUniquePosition() {
         let x=random(margin[0][0]+osRadius, canvasWidth-margin[0][1]-osRadius);
         let y=random(margin[1][0]+osRadius, canvasHeight-margin[1][1]-osRadius);

         for (let i=0; i<os.length; i++) {
            if ((x>os[i].x-osRadius&&x<os[i].x+osRadius)||(y>os[i].y-osRadius&&y<os[i].y+osRadius)) {
               return getUniquePosition();
            }
         }

         return [parseFloat(x.toFixed(1)), parseFloat(y.toFixed(1))];
      }

      function setup() {
         createCanvas(canvasWidth, canvasHeight);

         for (let i=0; i<maxOs; i++) {
            const p=getUniquePosition();
            os.push({
               x: p[0],
               y: p[1],
               vx: random(-2, 2),
               vy: random(-2, 2),
               r: random(0, 255),
               g: random(0, 255),
               b: random(0, 255),
            });
         }
      }

      function draw() {
         background(250);
         stroke(0);
         noFill();
         rect(margin[0][0], margin[1][0], canvasWidth-margin[0][0]-margin[0][1], canvasHeight-margin[1][0]-margin[1][1]);

         for (let o of os) {
            if (o.x<margin[0][0]+osRadius/2) o.x=canvasWidth-margin[0][1]-osRadius*2;
            if (o.x>canvasWidth-margin[0][1]-osRadius/2) o.x=margin[0][0]+osRadius/2;

            if (o.y<margin[1][0]+osRadius/2) o.y=canvasHeight-margin[1][1]-osRadius*2;
            if (o.y>canvasWidth-margin[1][1]-osRadius/2) o.y=margin[1][0]+osRadius/2;

            // if (o.x<margin[0][0]+osRadius/2||o.x>canvasWidth-margin[0][1]-osRadius/2) o.vx*=-1;
            // if (o.y<margin[1][0]+osRadius/2||o.y>canvasHeight-margin[1][1]-osRadius/2) o.vy*=-1;

            let c=false;
            for (let p of os) {
               if (o!==p) {
                  c=circlesIntersect(o.x, o.y, osRadius/2, p.x, p.y, osRadius/2);

                  if (c) {
                     const [vx1, vy1, vx2, vy2]=bounce(o.x, o.y, o.vx, o.vy, p.x, p.y, p.vx, p.vy);
                     o.vx=vx1;
                     o.vy=vy1;
                     p.vx=vx2;
                     p.vy=vy2;
                  }
               }
            }

            o.x-=o.vx;
            o.y-=o.vy;

            const textX=o.x.toFixed(1);
            const textY=o.y.toFixed(1);
            const textS=parseFloat(Math.sqrt(o.vx*o.vx+o.vy*o.vy).toFixed(2));

            // draw the object
            noStroke();
            fill(0);
            circle(o.x, o.y, osRadius);

            // draw the debug text
            fill(50, 150, 250);
            textSize(9);
            rect(o.x+10, o.y-4, textS*6, 2);
            rect(o.x+10, o.y-1, textX/10, 2);
            rect(o.x+10, o.y+2, textY/10, 2);
         }
      }
   </script>

</body>

</html>